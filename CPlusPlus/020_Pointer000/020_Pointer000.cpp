#include <iostream>

int main()
{
    {
        // int는 4byte 정수이다.
        // 아래 자료형은 8byte 정수이다.
        __int64 i64Value = 10;

        // 포인터란 c++의 자료형의 한 형태이다.
        // 자료형 뒤에 *을 붙이는 문법을 통해서 선언한다.

        int* iPtr;
        bool* bPtr;

        // 포인터는 RAM애서의 위치를 의미하게 된다.

        // 포인터가 만들어진 이유중 하나는 아래와 같다.
        // 포인터도 정수값으로 이루어진 주소이다.
        // 함수가 정수를 매개변수로 받았는데 이게 변수값인지 주소값인지 알 수 없다.
        // 그래서 만든 자료형이 포인터이다.

        // 포인터는 64bit 기준에서 8byte의 크기를 가진다.
        // 32bit는 4byte

        int Value0 = 10;
        int Value1 = 10;

        // 위 변수는 같은 영역의 stack에 저장되기 때문에 서로 주소가 가깝게 저장된다.
        // 아래 포인터를 디버깅 해보면 알 수 있다.
        int* ValuePtr0 = &Value0;
        int* ValuePtr1 = &Value1;


        // 형변환
        // 앞에 (자료형)을 사용하여 형변환을 할 수 있다.
        // 막상 배운것과는 다르게 주소값이 RAM보다 훨씬 크게 나오게 된다.
        // 이는 운영체제가 임의대로 주소를 부여해 주는 virtual 주소라고 한다.
        // 개념적인 부분이 지금까지 배운 이론이며 정확한 물리적 주소는 운영체제가 관리하기 때문에 설명이 어렵다.
        // 하지만 개념 자체는 달라지지 않았기 때문에 알고가야 한다.
        __int64 Address = (__int64)Value0;


        // 코드로 쳐졌다면 램의 어딘가에는 존재해야 한다.
        // 모든건 위치가있고 크기가 있어야한다
        // 주소값이라는 것은 램의 위치를 표현하는 정수이며 크기가 다르지 않다.
        // 주소값은 byte로 센다.(당연)
    }
    {
        int Value2 = 0b00000000000000000000000000000000; // Binary (2진수)
        int Value16 = 0xffffffffffffffff;  // Hexadecimal (16진수)
        int Value10 = 1; // Decimal (10진수)
        // 0b00000000000000000000000000000000
        // 0x   f   f   f   f   f   f   f   f (ffffffff)

    }
}